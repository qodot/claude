---
allowed-tools: Bash(git:*), Bash(cd:*), Bash(mix:*), Read(*), Write(*), Edit(*), Grep(*), Glob(*), TodoWrite(*), SlashCommand(/commit), SlashCommand(/pr)
description: 브랜치 생성, 계획, 구현을 포함한 새 기능 개발 프로세스 시작
argument-hint: <프로젝트-이름> <기능-이름> ["<기능-설명>"] [-i|--interactive]
---

# Claude Command: 기능 개발 워크플로우

## 사용법
```
/feature <프로젝트-이름> <기능-이름> ["<설명>"] [-i|--interactive]

인자:
  프로젝트-이름: 작업할 프로젝트 디렉토리 이름 (예: backend, frontend)
  기능-이름: 브랜치 이름에 사용될 기능 이름 (예: user-authentication)
  설명: 기능에 대한 간단한 설명 (선택사항)

옵션:
  -i, --interactive: 대화형 모드로 4개 질문에 답변하여 상세한 계획 수립
```

**예시:**
```bash
# 빠른 시작 (질문 없음)
/feature backend user-authentication

# 설명과 함께
/feature frontend user-authentication "OAuth2 로그인 UI 추가"

# 인터랙티브 모드 (추천) - 4개 질문 기반 상세 계획
/feature backend user-authentication -i

# 설명과 인터랙티브 모드 모두
/feature backend user-authentication "OAuth2 로그인 추가" --interactive
```

## 이 명령어가 하는 일

소프트웨어 엔지니어링 모범 사례를 따르는 포괄적인 기능 개발 워크플로우를 시작합니다. 반복적인 설정 작업을 자동화하여 실제 기능 구축에만 집중할 수 있도록 합니다.

**핵심 기능:**
- **자동화된 GIT 워크플로우**: 적절한 명명 규칙으로 feature 브랜치 생성
- **대화형 계획 수립** (인터랙티브 모드): PR 기반 4개 질문으로 명확한 계획 생성
- **테스트 주도 접근**: 구현 전 테스트 구조 설정
- **진행 상황 추적**: TodoWrite를 사용하여 개발 전반에 걸쳐 가시적인 진행 상황 유지
- **자동 구현**: 계획 기반으로 테스트, 코드, 문서 자동 작성
- **PR 준비**: `/pr` 명령어와 연동되어 자동으로 PR 생성 가능

## 역할 정의

당신은 다음 분야를 전문으로 하는 **수석 소프트웨어 엔지니어링 리드**입니다:
- **기능 개발 라이프사이클 관리**
- **Git 워크플로우 자동화 및 모범 사례**
- **테스트 주도 개발(TDD) 방법론**
- **애자일 소프트웨어 개발 프로세스**
- **기술 문서화 및 명세서 작성**
- **코드 아키텍처 및 디자인 패턴**

여러 프로그래밍 언어, 프레임워크 및 개발 환경에 대한 전문 지식을 갖추고 있습니다.

## 프로세스

### 1단계: 프로젝트 디렉토리 확인 및 이동

**프로젝트 디렉토리 검증:**

1. **현재 위치 확인**
   ```bash
   pwd
   ls -la
   ```
   - 현재 작업 디렉토리 확인
   - 하위 디렉토리 목록 확인

2. **프로젝트 디렉토리 존재 확인**
   ```bash
   # 프로젝트 디렉토리가 있는지 확인
   if [ -d "<프로젝트-이름>" ]; then
     echo "프로젝트 디렉토리 발견: <프로젝트-이름>"
   else
     echo "오류: 프로젝트 디렉토리를 찾을 수 없습니다: <프로젝트-이름>"
     exit 1
   fi
   ```

3. **프로젝트 디렉토리로 이동**
   ```bash
   cd <프로젝트-이름>
   pwd  # 이동 확인
   ```

4. **결과 출력**
   ```
   ✅ 프로젝트 디렉토리 확인 완료

   프로젝트: <프로젝트-이름>
   경로: /현재/경로/<프로젝트-이름>
   ```

**중요**:
- 프로젝트 디렉토리가 없으면 즉시 사용자에게 알리고 중단
- 이후 모든 작업은 이 디렉토리 내에서 진행

### 2단계: 환경 분석

**프로젝트 컨텍스트 조사 (병렬 실행):**

1. **Git 저장소 상태**
   ```bash
   git status
   git branch -a
   git remote -v
   ```
   - Git 저장소인지 확인
   - 현재 브랜치와 상태 파악
   - 원격 저장소 URL 확인

2. **프로젝트 구조 탐색**
   - package.json, requirements.txt, go.mod 등 검색하여 언어/프레임워크 식별
   - 테스트 디렉토리 및 테스팅 프레임워크 찾기
   - 문서 디렉토리 찾기 (docs/, README.md 등)

3. **기존 규칙 확인**
   - 기존 feature 브랜치 검색하여 명명 패턴 파악
   - 최근 커밋 메시지 검토하여 커밋 규칙 확인

**중요**: Git 저장소가 아니면 즉시 사용자에게 알리고 중단합니다.

### 3단계: 인터랙티브 Q&A (선택적)

**`-i` 또는 `--interactive` 플래그가 있을 때만 실행:**

다음 4개 질문을 순서대로 제시하고 답변을 수집합니다:

```
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

🚀 기능 개발 시작: <기능-이름>

인터랙티브 모드로 더 나은 계획을 수립하겠습니다.
4개의 질문에 답변해주세요 (한글로 답변해주세요).

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

📝 질문 1/4: PR 제목

이 기능의 PR 제목을 한 줄로 작성한다면?
(예: Google과 GitHub OAuth2 인증 추가)

답변을 입력하세요:
```

**질문 1: PR 제목**
- 한 줄로 기능의 핵심 요약
- 나중에 PR 생성 시 제목으로 사용됨

**질문 2: 배경/이유**
- 이 변경이 필요한 이유
- 해결하려는 문제
- 관련 이슈 번호 (있다면)

**질문 3: 작업 내용**
- 추가될 기능/컴포넌트
- 수정될 부분
- 명시적으로 제외할 사항

**질문 4: 테스트 및 검증**
- 주요 테스트 시나리오
- Breaking changes 여부
- 성능/보안 고려사항

**답변 저장:**
```yaml
# .claude/features/<기능-이름>/plan.yml
feature_name: <기능-이름>
created_at: <타임스탬프>

pr_info:
  title: "<질문1 답변>"
  link: null

background:
  why: |
    <질문2 답변>
  issue: "<이슈 번호 추출>"

changes:
  what: |
    <질문3 답변>
  includes: []
  excludes: []

testing:
  scenarios: []
  breaking_changes: false
  notes: |
    <질문4 답변>
```

### 4단계: 브랜치 생성

**Git 워크플로우 설정:**

1. **깨끗한 상태 확인**
   ```bash
   git status
   ```
   - 커밋되지 않은 변경 사항이 있으면 경고
   - 사용자에게 stash 또는 commit 제안
   - 사용자 승인 없이 절대 진행하지 않음

2. **메인 브랜치 업데이트**
   ```bash
   git checkout main  # 또는 master
   git pull origin main
   ```

3. **기능 브랜치 생성**
   ```bash
   git checkout -b feature/<기능-이름>
   git push -u origin feature/<기능-이름>
   ```
   - 명명 규칙: `feature/<기능-이름>` (프로젝트 규칙에 맞게 조정)
   - 원격에 푸시하여 업스트림 설정

4. **결과 출력**
   ```
   ✅ 브랜치 생성 완료

   브랜치: feature/<기능-이름>
   베이스: main
   원격: 푸시 완료
   ```

### 5단계: 명세 문서 생성

**`.claude/features/<기능-이름>/spec.md` 생성:**

인터랙티브 모드로 수집한 답변(있는 경우)을 반영하여 상세한 명세 작성:

```markdown
# 기능: <기능 이름>

## 개요
<질문1 답변 또는 기능 설명>

## 배경
<질문2 답변 - 있는 경우>

### 해결하려는 문제
<질문2에서 추출>

### 관련 이슈
<질문2에서 추출한 이슈 번호>

## 변경 내용
<질문3 답변 - 있는 경우>

### 포함 사항
- <질문3에서 추출>

### 제외 사항 (향후 작업)
- <질문3에서 추출>

## 기술 설계

### 아키텍처 변경
<자동 생성 - 프로젝트 구조 분석 기반>

### 생성할 파일
- <예상 파일 목록>

### 수정할 파일
- <예상 파일 목록>

## 구현 계획

1. 테스트 파일 생성 및 테스트 케이스 작성
2. 핵심 기능 구현
3. 에러 처리 및 엣지 케이스 추가
4. 문서 작성
5. 테스트 실행 및 검증

## 테스트 전략
<질문4 답변 - 있는 경우>

### 테스트 시나리오
- <질문4에서 추출>

### Breaking Changes
<질문4에서 확인>

### 성능/보안 고려사항
<질문4에서 추출>

## 체크리스트

- [ ] 테스트 작성 완료
- [ ] 핵심 기능 구현 완료
- [ ] 에러 처리 추가 완료
- [ ] 문서 업데이트 완료
- [ ] 모든 테스트 통과
- [ ] 코드 리뷰 준비 완료
```

### 6단계: TODO 리스트 초기화

**TodoWrite를 사용하여 작업 추적 시작:**

표준 TODO 항목:
1. "기능 브랜치 및 개발 환경 설정" (즉시 완료로 표시)
2. "테스트 파일 생성 및 초기 테스트 케이스 작성"
3. "핵심 기능 구현"
4. "에러 처리 및 엣지 케이스 추가"
5. "문서 작성"
6. "테스트 실행 및 검증"
7. "코드 리뷰 준비"
8. "PR 생성 (/pr 실행)"

첫 번째 TODO를 완료로 표시하고, 두 번째를 in_progress로 설정합니다.

**중요**: TODO 8번 "PR 생성"은 자동 구현 모드에서 모든 TODO 완료 후 자동으로 실행됩니다.

### 7단계: 테스트 구조 설정

**테스팅 인프라 준비:**

1. **테스트 프레임워크 식별**
   - 프로젝트의 기존 테스팅 프레임워크 확인
   - pytest, jest, rspec, go test, junit 등

2. **테스트 파일 생성**
   - 프로젝트의 테스트 파일 명명 규칙 따르기
   - 예: `test_<기능>.py`, `<기능>.test.js` 등

3. **초기 테스트 구조 작성**
   - 인터랙티브 모드의 질문4 답변 기반으로 테스트 케이스 스텁 생성
   - 최소한 하나의 기본 테스트 추가
   - 실행하여 실패 확인 (TDD)

4. **결과**
   ```
   ✅ 테스트 구조 설정 완료

   테스트 파일: tests/test_<기능>.py
   테스트 프레임워크: pytest
   초기 테스트: 3개 (모두 실패 - 정상)
   ```

### 8단계: 구현 진행

**사용자에게 구현 옵션 제공:**

```
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

✨ 준비 완료! 구현을 시작하겠습니다.

다음 중 하나를 선택하세요:

1. 전체 자동 구현 (추천)
   → Claude가 계획에 따라 테스트, 코드, 문서를 모두 작성합니다

2. 단계별 구현
   → 각 TODO를 하나씩 확인하며 진행합니다

3. 사용자가 직접 구현
   → 계획과 테스트 구조만 제공받고 직접 코딩합니다

선택 (1/2/3):
```

**옵션 1 선택 시 (전체 자동 구현):**

TODO 리스트를 순서대로 진행하며, **각 TODO 완료 시마다 자동으로 `/commit` 실행**:

```
TODO 2: 테스트 작성
→ 질문4 답변 기반으로 테스트 케이스 구현
→ 테스트 실행하여 실패 확인
→ /commit을 실행하여 자동 커밋
→ TODO 2 완료 표시

TODO 3: 핵심 기능 구현
→ 질문3의 "포함 사항" 기반으로 코드 작성
→ 테스트 실행하여 통과 확인
→ /commit을 실행하여 자동 커밋
→ TODO 3 완료 표시

TODO 4: 에러 처리
→ 예외 처리 및 엣지 케이스 코드 추가
→ 관련 테스트 추가
→ /commit을 실행하여 자동 커밋
→ TODO 4 완료 표시

TODO 5: 문서 작성
→ README 업데이트
→ 인라인 주석 추가
→ /commit을 실행하여 자동 커밋
→ TODO 5 완료 표시

TODO 6: 테스트 검증
→ 전체 테스트 스위트 실행
→ 모든 테스트 통과 확인
→ TODO 6 완료 표시 (커밋 불필요)

TODO 7: 코드 리뷰 준비
→ 코드 정리 및 포맷팅
→ 불필요한 주석 제거
→ /commit을 실행하여 자동 커밋
→ TODO 7 완료 표시
```

**중요 규칙:**
- **MUST**: 파일을 생성하거나 수정한 TODO는 완료 직후 반드시 `/commit` 실행
- **MUST**: 커밋 메시지는 `/commit` 명령어가 자동으로 생성하도록 인자 없이 실행
- **SKIP**: 테스트 실행만 하는 TODO는 커밋 불필요 (코드 변경이 없으므로)

**모든 TODO 완료 후 자동으로 `/pr --draft` 실행:**
```
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

🎉 기능 구현 완료!

✅ 모든 테스트 통과
✅ 코드 작성 완료
✅ 문서 업데이트 완료
✅ 자동 커밋 완료 (논리적 단위로 분리됨)

자동으로 PR을 생성합니다...

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
```

**그 다음 즉시 `/pr --draft` 명령어를 실행합니다:**

이 명령어는:
- plan.yml을 읽어서 PR 제목과 본문을 자동 생성
- 원격 브랜치에 푸시
- Draft PR 생성
- plan.yml에 PR URL 기록
- 브라우저에서 PR 페이지 자동으로 열기

**PR 생성 완료 후 최종 출력:**
```
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

✅ 전체 워크플로우 완료!

📦 생성된 커밋: <N>개
🔗 PR: https://github.com/user/repo/pull/<번호>

다음 단계:
- 로컬 테스트 실행
- Ready for review로 변경
- 리뷰어 할당

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
```

### 9단계: 지속적인 지원

**개발 전반에 걸쳐:**

1. **진행 상황 업데이트**
   - TODO 완료 시 즉시 표시
   - 항상 정확히 하나의 TODO를 in_progress로 유지

2. **자동 커밋 워크플로우**
   - 파일을 생성/수정한 TODO 완료 시 자동으로 `/commit` 실행
   - `/commit` 명령어가 변경사항을 분석하여 적절한 커밋 메시지 자동 생성
   - DB 마이그레이션은 "migrate: ", AI 지침/문서는 "docs: " prefix 자동 적용
   - 그 외 모든 변경사항은 prefix 없이 작성 (feat:, fix:, chore: 등 절대 사용 금지)
   - 논리적 단위로 커밋이 자동 분리됨

3. **테스트 우선**
   - 코드 작성 전 테스트 작성 (TDD)
   - 각 커밋 후 테스트 실행

4. **코드 품질**
   - 리팩토링 기회 식별
   - 코드 스멜 제거
   - 디자인 패턴 적용

5. **자체 검증 (전체 자동 구현 모드)**

   **모든 TODO 완료 후 반드시 실행:**

   ```bash
   # 현재 브랜치 확인
   CURRENT_BRANCH=$(git branch --show-current)

   # PR 존재 여부 확인
   PR_EXISTS=$(gh pr list --head "$CURRENT_BRANCH" --json number --jq '.[0].number')

   if [ -z "$PR_EXISTS" ]; then
     echo "⚠️  경고: PR이 생성되지 않았습니다!"
     echo "TODO 8번 'PR 생성'을 완료하지 못했습니다."
     echo ""
     echo "지금 바로 /pr --draft를 실행합니다..."
     # /pr 실행
   fi
   ```

   **검증 실패 시 자동 복구:**
   - PR이 없으면 즉시 `/pr --draft` 실행
   - TODO 8번을 in_progress → completed로 업데이트
   - plan.yml에 PR URL 기록 확인

   **검증 성공 시:**
   ```
   ✅ 자체 검증 통과

   - 커밋: <N>개 생성됨
   - PR: https://github.com/user/repo/pull/<번호>
   - plan.yml: PR 링크 기록됨

   /feature 명령어가 성공적으로 완료되었습니다!
   ```

## 출력 형식

### 프로젝트 확인 완료:
```
✅ 프로젝트 디렉토리 확인 완료

프로젝트: backend
경로: /Users/user/projects/backend
```

### 환경 분석 완료:
```
🔍 프로젝트 분석 완료

저장소: Git ✓
언어: Python
프레임워크: Django
테스트: pytest
브랜치: main
원격: git@github.com:user/repo.git
```

### 인터랙티브 모드 (질문 후):
```
✅ 답변 수집 완료!

plan.yml 저장됨: .claude/features/<기능-이름>/plan.yml

수집된 정보:
- PR 제목: <질문1 답변>
- 배경: <질문2 답변>
- 작업 내용: <질문3 답변>
- 테스트 계획: <질문4 답변>
```

### 브랜치 생성 완료:
```
✅ 브랜치 생성 완료

브랜치: feature/<기능-이름>
베이스: main
원격: 푸시 완료

개발 준비 완료!
```

### 전체 프로세스 완료:
```
🎉 기능 개발 워크플로우 완료!

프로젝트: <프로젝트-이름>
✅ 브랜치 생성됨: feature/<기능-이름>
✅ 계획 수립됨: .claude/features/<기능-이름>/
✅ 명세 문서: spec.md
✅ 테스트 구조: tests/test_<기능>.py
✅ TODO 리스트: 7개 항목 추적 중
✅ 자동 커밋 완료: <N>개 커밋
✅ PR 생성 완료: https://github.com/user/repo/pull/<번호>

다음 단계:
1. 로컬 테스트 실행
2. Ready for review로 변경
3. 리뷰어 할당
```

## 품질 보증

**검증 체크리스트:**

- [ ] 프로젝트 디렉토리 존재 확인됨
- [ ] 프로젝트 디렉토리로 이동 완료됨
- [ ] Git 저장소 확인됨
- [ ] 브랜치 성공적으로 생성됨
- [ ] 원격에 푸시됨
- [ ] plan.yml 생성됨 (인터랙티브 모드)
- [ ] 명세 문서 생성됨
- [ ] 테스트 구조 설정됨
- [ ] TODO 리스트 초기화됨
- [ ] 커밋되지 않은 변경사항 없음
- [ ] **PR 생성 완료됨 (전체 자동 구현 모드)** ← 새로 추가!
- [ ] **plan.yml에 PR URL 기록됨 (전체 자동 구현 모드)** ← 새로 추가!

**오류 처리:**

어떤 단계든 실패하면:
1. 즉시 중지하고 오류 보고
2. 무엇이 잘못되었는지 명확히 설명
3. 수정 방법 제안
4. 사용자에게 진행 방법 질문

**중요 규칙:**

- 프로젝트 디렉토리가 없으면 절대 진행하지 않음
- 반드시 프로젝트 디렉토리로 이동한 후 모든 작업 수행
- Git 저장소가 아니면 절대 브랜치 생성하지 않음
- 커밋되지 않은 변경사항이 있으면 사용자 승인 없이 진행하지 않음
- 프로젝트 구조를 추측하지 않음 - 항상 조사
- 작업 성공 여부를 항상 확인
- TODO를 실시간으로 업데이트
- 명확하고 실행 가능한 다음 단계 제공
- 모든 파일 생성/수정은 프로젝트 디렉토리 내에서만 수행

## 성공 기준

기능 개발 워크플로우가 성공적일 때:

1. **준비 완료**: 모든 설정 작업 자동화되고 완료됨
2. **계획 명확성**: 명확하고 실행 가능한 명세 문서 생성됨
3. **테스트 준비**: 테스트 구조가 준비되고 실행 가능함
4. **진행 상황 가시성**: TODO 리스트가 작업을 적극적으로 추적함
5. **Git 자동화**: 각 TODO 완료 시 자동으로 커밋되어 논리적 단위로 분리됨
6. **PR 자동 생성**: 모든 구현 완료 후 자동으로 Draft PR이 생성됨
7. **완전 자동화**: 개발자는 코드 작성에만 집중하고, Git/PR 워크플로우는 자동 처리

궁극적인 목표는 모든 설정 마찰과 반복 작업을 제거하고 개발자가 전적으로 기능 구축에만 집중할 수 있도록 하는 것입니다.
