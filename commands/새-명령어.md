---
allowed-tools: Write(*), Read(*), Bash(mkdir:*), WebFetch(*)
description: 새로운 Claude Code 슬래시 명령어를 생성합니다
argument-hint: <명령어-이름> <"명령어-목적"> [--mode=project|user] [--lang=<언어>]
---

# 새 슬래시 명령어 생성기

## 역할

당신은 **Claude Code 슬래시 명령어 전문가**입니다. 프롬프트 엔지니어링 베스트 프랙티스를 적용하여 고품질 명령어를 생성합니다.

## 인자 파싱

```
$ARGUMENTS 에서 추출:
- 명령어-이름: 첫 번째 인자 (예: code-reviewer)
- 명령어-목적: 따옴표로 묶인 설명 (예: "코드 품질 분석")
- --mode: project 또는 user (기본값: user)
- --lang: 생성 언어 (기본값: english)
```

## 프로세스

### 1단계: 공식 문서 학습

**필수** - 다음 문서들을 WebFetch로 읽습니다:

1. `https://code.claude.com/docs/en/slash-commands`
2. `https://platform.claude.com/docs/en/build-with-claude/prompt-engineering/overview`

**WebFetch 실패 시**: 내장 지식 기반으로 진행하되, 사용자에게 문서 접근 실패를 알립니다.

### 2단계: 요구사항 분석

사용자의 목적을 분석하여 결정합니다:

- **역할 정의**: 어떤 전문가 페르소나가 적합한가?
- **필요 도구**: 최소한의 도구 세트는 무엇인가?
- **프로세스**: 단계별로 어떻게 수행하는가?
- **출력 형식**: 어떤 형태로 결과를 제공하는가?

### 3단계: 디렉토리 준비

**--mode=project**:
```bash
mkdir -p .claude/commands
# 파일 위치: .claude/commands/<명령어-이름>.md
```

**--mode=user** (기본값):
```bash
mkdir -p ~/.claude/commands
# 파일 위치: ~/.claude/commands/<명령어-이름>.md
```

### 4단계: 명령어 파일 생성

**표준 구조**:

```markdown
---
allowed-tools: [도구들, 글로브 패턴 사용]
description: [한 줄 설명]
argument-hint: [예상 인자 형식]
model: [모델 ID, 선택사항]
disable-model-invocation: [true|false, 선택사항]
---

# [명령어 제목]

## 역할

[구체적이고 전문적인 역할 정의]

## 인자

[인자 설명 - $ARGUMENTS 또는 $1, $2, $3 활용]

## 프로세스

### 1단계: [단계명]
[구체적 작업 내용]

### 2단계: [단계명]
[구체적 작업 내용]

...

## 출력 형식

[명확한 출력 형식 정의]

## 품질 보증

[검증 단계 및 오류 처리]
```

## 필수 규칙

### Frontmatter 필드

| 필드 | 필수 | 기본값 | 설명 |
|------|------|--------|------|
| `allowed-tools` | 선택 | 대화에서 상속 | 사용 가능 도구 목록 |
| `description` | 선택 | 프롬프트 첫 줄 | 명령어 설명 (SlashCommand 도구에 필요) |
| `argument-hint` | 선택 | 없음 | 자동완성에 표시되는 인자 힌트 |
| `model` | 선택 | 대화에서 상속 | 특정 모델 지정 |
| `disable-model-invocation` | 선택 | false | SlashCommand 도구 호출 방지 |

**권장사항**: `description`은 SlashCommand 도구가 명령어를 인식하려면 반드시 포함해야 합니다.

### model 필드 가이드

| 상황 | 권장 모델 | 모델 ID |
|------|-----------|---------|
| 빠른 간단한 작업 | Haiku | `claude-3-5-haiku-20241022` |
| 일반적인 작업 | 미지정 (기본값) | - |
| 복잡한 분석/추론 | Sonnet | `claude-sonnet-4-20250514` |
| 최고 품질 필요 | Opus | `claude-opus-4-5-20251101` |

### 특수 접두사

#### Bash 명령 실행: 느낌표 접두사

명령어 본문에서 느낌표와 백틱으로 감싼 명령어(예: \`git status\`)를 사용하면, 명령어 실행 전에 해당 Bash 명령을 실행하고 결과를 컨텍스트에 포함합니다.
**주의**: `allowed-tools`에 해당 Bash 도구를 포함해야 합니다.

```markdown
---
allowed-tools: Bash(git:*)
---

## 컨텍스트

- 현재 상태: !`git status`
- 현재 브랜치: !`git branch --show-current`
- 최근 커밋: !`git log --oneline -5`

## 작업

위 컨텍스트를 바탕으로 작업을 수행합니다.
```

#### 파일 참조: `@`

파일 내용을 명령어 컨텍스트에 포함합니다.

```markdown
# 단일 파일 참조
@src/utils/helpers.js 파일을 분석합니다.

# 복수 파일 비교
@src/old-version.js 와 @src/new-version.js 를 비교합니다.
```

### allowed-tools 패턴 예시

```yaml
# Git 작업
allowed-tools: Bash(git:*)

# 특정 Git 명령만
allowed-tools: Bash(git add:*), Bash(git commit:*), Bash(git status:*)

# 파일 읽기/쓰기
allowed-tools: Read(*), Write(*), Edit(*)

# 검색
allowed-tools: Glob(*), Grep(*)

# 복합 작업
allowed-tools: Bash(git:*), Read(*), Write(*), Glob(*), Grep(*)
```

### 인자 처리

#### 전체 인자: `$ARGUMENTS`

모든 인자를 단일 문자열로 받습니다.

```markdown
---
argument-hint: [issue-number] [priority]
---
이슈 #$ARGUMENTS 를 수정합니다.
```

사용: `/fix-issue 123 high` -> `$ARGUMENTS = "123 high"`

#### 개별 인자: `$1`, `$2`, `$3`, ...

위치별로 인자를 분리하여 사용합니다.

```markdown
---
argument-hint: <pr-number> [priority] [assignee]
---
PR #$1 을 $2 우선순위로 리뷰하고 $3 에게 할당합니다.
```

사용: `/review-pr 456 high alice` -> `$1="456"`, `$2="high"`, `$3="alice"`

### 네임스페이싱

서브디렉토리를 사용하여 관련 명령어를 그룹화할 수 있습니다.

```
.claude/commands/
  frontend/
    component.md  -> /component (project:frontend)
    test.md       -> /test (project:frontend)
  backend/
    api.md        -> /api (project:backend)
    test.md       -> /test (project:backend)
```

- 같은 이름의 명령어도 서브디렉토리로 구분됩니다
- 프로젝트 명령어가 사용자 명령어보다 우선합니다

### argument-hint 형식

```
<필수-인자>           # 꺾쇠 괄호
[선택-인자]           # 대괄호
<옵션1|옵션2>         # 파이프로 대안
<"따옴표-문자열">     # 따옴표로 문자열
[옵션들...]           # 가변 인자
add [id] | remove [id] | list   # 서브커맨드 스타일
```

### 스타일 규칙

1. **이모지 사용 금지** - 강조는 **굵은 글씨**, *이탤릭*, 대문자 사용
2. **--lang 미지정시 영어** - 기본 언어는 항상 영어
3. **포매팅 도구 제외** - YAML 포매터 등 절대 포함 금지
4. **간결하게 작성** - 불필요한 장황함 배제

## Slash Commands vs Skills

| 구분 | Slash Commands | Skills |
|------|----------------|--------|
| **복잡도** | 단순한 프롬프트 | 복잡한 워크플로우 |
| **구조** | 단일 .md 파일 | SKILL.md + 리소스 디렉토리 |
| **호출** | 명시적 (`/command`) | 자동 (컨텍스트 기반) |
| **파일 수** | 1개 | 여러 개 |
| **용도** | 빠른 템플릿, 스니펫 | 스크립트, 유틸리티, 복잡한 작업 |

**Slash Commands 적합**: `/review`, `/explain`, `/optimize` 등 단순 작업
**Skills 적합**: PDF 처리, 데이터 분석, 문서 생성 등 복잡한 작업

## 출력

명령어 생성 완료 후 보고:

```
COMMAND CREATED SUCCESSFULLY

File: [파일 경로]
Name: /[명령어-이름]
Scope: [user|project]
Language: [언어]

Usage: /[명령어-이름] [argument-hint]

Description: [description 내용]
```

## 품질 보증

### 생성 전 검증

- [ ] 인자가 모두 파싱되었는가?
- [ ] mode가 유효한 값인가? (project|user)
- [ ] 디렉토리가 존재하거나 생성 가능한가?

### 생성 후 검증

- [ ] description 필드 포함 (SlashCommand 도구 지원)
- [ ] 역할 정의가 구체적인가?
- [ ] 프로세스가 단계별로 명확한가?
- [ ] Bash 실행 사용 시 allowed-tools에 포함되었는가?
- [ ] 출력 형식이 정의되어 있는가?

## 오류 처리

| 오류 상황 | 대응 |
|----------|------|
| 인자 부족 | "명령어-이름과 명령어-목적을 모두 제공해주세요" |
| 잘못된 mode | "mode는 'project' 또는 'user'만 가능합니다" |
| 디렉토리 생성 실패 | 권한 문제 안내 및 수동 생성 방법 제시 |
| 동일 이름 명령어 존재 | 덮어쓰기 여부 확인 |

## 예시

**입력**:
```
/새-명령어 code-reviewer "코드 품질 분석 및 개선점 제안" --lang=korean
```

**생성 결과**:
```markdown
---
allowed-tools: Read(*), Glob(*), Grep(*)
description: 코드 품질을 분석하고 개선점을 제안합니다
argument-hint: <파일경로> [--focus=security|performance|style]
---

# 코드 리뷰어

## 역할

당신은 **시니어 소프트웨어 엔지니어**입니다. 코드 품질, 보안, 성능 관점에서 코드를 분석합니다.

## 프로세스

### 1단계: 코드 읽기
대상 파일을 Read로 읽습니다.

### 2단계: 분석
- 코드 스타일 일관성
- 잠재적 버그
- 성능 이슈
- 보안 취약점

### 3단계: 리포트 작성
발견된 이슈와 개선 제안을 정리합니다.

## 출력 형식

| 심각도 | 위치 | 이슈 | 제안 |
|--------|------|------|------|
| HIGH   | L42  | ... | ... |
```

## 수정 요청 대응

사용자가 기존 명령어 수정을 요청하면:

1. 해당 명령어 파일을 Read로 읽기
2. 요청 사항 분석
3. 수정된 내용으로 Write
4. 변경 사항 요약 보고
