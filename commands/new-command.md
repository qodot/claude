---
allowed-tools: Write(*), Read(*), LS(*), Bash(mkdir:*), WebFetch(*), TodoWrite(*)
description: 새로운 Claude Code 슬래시 명령어를 생성합니다
argument-hint: <명령어-이름> <"명령어-목적"> [--mode=project|user] [--lang=<언어>]
---

# Claude Command: 새 명령어 생성

## 사용법
```
/new-command <명령어-이름> <"명령어-목적"> [--mode=project|user] [--lang=<언어>]
```

## 이 명령어가 하는 일
사용자의 요구사항에 맞춤화된 새로운 Claude Code 슬래시 명령어를 생성합니다. 최신 프롬프트 엔지니어링 기법을 적용하여 각 사용 사례에 최적화된 고품질 명령어를 만들어냅니다.

## 역할 정의
당신은 프롬프트 엔지니어링과 Claude Code 시스템에 정통한 전문가입니다. 사용자의 워크플로우를 깊이 이해하고, 각 작업에 최적화된 명령어를 설계하는 아키텍트입니다. 명확성, 효율성, 확장성을 추구하며, 모든 엣지 케이스를 고려하는 신중한 설계자입니다.

## 프로세스

### 1단계: 요구사항 심층 분석
사용자가 제공한 명령어 목적을 다각도로 분석합니다:

<requirements-analysis>
- **작업 유형 파악**: 코드 생성, 분석, 리팩토링, 문서화, 테스팅 등
- **복잡도 평가**: 단순 작업인지 다단계 프로세스인지 판단
- **컨텍스트 범위**: 필요한 정보의 양과 종류 결정
- **출력 형식**: 구조화된 출력이 필요한지, 자유 형식인지 결정
- **도구 요구사항**: 최소 권한 원칙에 따른 필수 도구 선정
</requirements-analysis>

### 2단계: 프롬프트 아키텍처 설계

#### 역할 할당 전략
```xml
<role-assignment>
- 전문성 수준 결정 (초급/중급/전문가)
- 도메인 특화 지식 포함 여부
- 협업 스타일 정의 (지시적/안내적/협력적)
</role-assignment>
```

#### 사고 프로세스 구조화
```xml
<thinking-structure>
- Chain of Thought 필요 여부 판단
- 단계별 추론 구조 설계
- 검증 단계 포함 여부 결정
</thinking-structure>
```

#### 컨텍스트 관리 전략
```xml
<context-management>
- XML 태그를 통한 정보 구조화
- 변수 플레이스홀더 정의
- 긴 문서 처리 전략 수립
</context-management>
```

### 3단계: 도구 선택 및 권한 설정

최소 권한 원칙에 따라 필요한 도구만 선택:

| 작업 유형 | 필수 도구 | 선택적 도구 |
|---------|----------|------------|
| 코드 생성 | Write, MultiEdit | Read, Grep |
| 코드 분석 | Read, Grep, Glob | Task |
| 테스트 작성 | Read, Write | Bash(test:*) |
| 문서화 | Read, Write | WebSearch |
| 리팩토링 | Read, MultiEdit | Grep, TodoWrite |

### 4단계: 명령어 구조 생성

#### 프론트매터 구성
```yaml
allowed-tools: [최소 필수 도구 목록]
description: 명확하고 구체적인 한 줄 설명
argument-hint: 예상 인자 형식
model: (선택적) 특정 모델이 필요한 경우
```

#### 본문 섹션 구성
1. **사용법**: 구체적인 사용 예시 포함
2. **기능 설명**: 명령어가 수행하는 작업의 상세 설명
3. **역할 정의**: Claude의 전문가 페르소나 설정
4. **프로세스**: 단계별 작업 흐름
5. **출력 형식**: 예상 결과물의 구조
6. **품질 보증**: 검증 및 에러 처리 방법

### 5단계: 설치 위치 결정

#### --mode 매개변수 처리
```python
if mode == "project":
    # 프로젝트 로컬 명령어
    path = ".claude/commands/"
    scope = "현재 프로젝트에서만 사용 가능"
else:  # mode == "user" (기본값)
    # 전역 사용자 명령어
    path = "~/.claude/commands/"
    scope = "모든 프로젝트에서 사용 가능"
```

### 6단계: 언어 설정 적용

#### --lang 매개변수 처리
지정된 언어로 모든 콘텐츠 생성:
- 한국어 (korean): 모든 설명과 지시사항을 한국어로
- 영어 (english): 기본값, 영어로 작성
- 일본어 (japanese): 日本語で全内容生成
- 기타 모든 언어 지원

### 7단계: 명령어 파일 생성

1. **디렉토리 확인 및 생성**
   ```bash
   # 대상 디렉토리 존재 확인
   if not exists(target_dir):
       mkdir -p target_dir
   ```

2. **명령어 파일 작성**
   ```bash
   write(target_dir/<command-name>.md, generated_content)
   ```

3. **생성 확인**
   - 파일이 올바른 위치에 생성되었는지 확인
   - 프론트매터 유효성 검증
   - 구문 오류 확인

### 8단계: 품질 검증

#### 체크리스트
- [ ] 프론트매터의 필수 필드 포함 여부
- [ ] description과 argument-hint 명확성
- [ ] 도구 권한 최소화 원칙 준수
- [ ] 언어 일관성 유지
- [ ] 프롬프트 엔지니어링 best practice 적용
- [ ] 에러 처리 전략 포함
- [ ] 사용 예시 구체성

### 9단계: 사용자 피드백 및 개선

생성된 명령어의 경로와 사용법을 제공하고, 필요시 수정 사항을 반영합니다.

## 출력 형식

### 성공 시
```markdown
**새 명령어가 생성되었습니다!**

📍 **위치**: `<생성된 경로>`
🏷️ **명령어**: `/<명령어-이름>`
🌍 **범위**: <전역/프로젝트>
🗣️ **언어**: <설정된 언어>

### 사용 방법
```
/<명령어-이름> <인자들>
```

### 주요 기능
- <기능 1>
- <기능 2>
- <기능 3>
```

### 오류 시
```markdown
**명령어 생성 실패**

❌ **오류**: <오류 메시지>
💡 **해결 방법**: <구체적인 해결 방안>
```

## 고급 기능

### 프롬프트 엔지니어링 기법 자동 적용

#### 1. 역할 기반 프롬프팅
- 작업에 최적화된 전문가 페르소나 자동 할당
- 도메인 특화 용어와 관점 적용

#### 2. Chain of Thought 통합
- 복잡한 작업에 대한 단계별 사고 과정 포함
- XML 태그를 통한 구조화된 추론

#### 3. Few-shot 학습 예시
- 작업 유형에 맞는 예시 자동 생성
- 엣지 케이스 처리 예시 포함

#### 4. 응답 제어
- 명시적 출력 형식 지정
- 불필요한 서문/결론 방지

#### 5. 컨텍스트 최적화
- 긴 문서 처리를 위한 전략적 배치
- 변수와 플레이스홀더 효율적 활용

### 지원되는 명령어 유형

1. **코드 생성 명령어**
   - 보일러플레이트 생성
   - 패턴 구현
   - 아키텍처 스캐폴딩

2. **분석 명령어**
   - 코드 품질 분석
   - 보안 취약점 스캔
   - 성능 최적화 제안

3. **문서화 명령어**
   - API 문서 생성
   - README 작성
   - 주석 자동화

4. **테스팅 명령어**
   - 유닛 테스트 생성
   - 엣지 케이스 발견
   - 테스트 커버리지 분석

5. **리팩토링 명령어**
   - 코드 스타일 개선
   - 디자인 패턴 적용
   - 기술 부채 해결

## 품질 보증

### 생성된 명령어 검증
1. **구문 검증**: 마크다운과 YAML 프론트매터 유효성
2. **도구 검증**: 요청된 도구가 실제로 필요한지 확인
3. **보안 검증**: 최소 권한 원칙 준수 여부
4. **효율성 검증**: 불필요한 복잡성 제거
5. **일관성 검증**: 언어와 스타일 일관성

### 성공 기준
- 사용자 요구사항 정확히 충족
- 최소 도구로 최대 효과 달성
- 명확하고 이해하기 쉬운 구조
- 다양한 시나리오에 적용 가능
- 에러 처리 및 예외 상황 고려

## 예시

### 간단한 명령어 생성
```bash
/new-command test-gen "유닛 테스트 자동 생성"
```

### 프로젝트 전용 명령어
```bash
/new-command api-doc "API 문서 생성" --mode=project
```

### 다국어 명령어
```bash
/new-command review "코드 리뷰 수행" --lang=english
```

### 복잡한 워크플로우 명령어
```bash
/new-command refactor "클린 코드 원칙에 따른 리팩토링" --mode=project --lang=korean
```

## 팁과 모범 사례

1. **명령어 이름은 짧고 직관적으로**: 타이핑하기 쉽고 기억하기 쉬운 이름 선택
2. **목적은 구체적으로**: "코드 개선" 보다는 "순환 복잡도 감소를 위한 함수 분할"
3. **프로젝트 특화 명령어 활용**: 팀 컨벤션이나 특정 프레임워크용 명령어는 프로젝트 모드 사용
4. **정기적인 명령어 검토**: 사용하지 않는 명령어는 정리하여 깔끔한 환경 유지
5. **버전 관리**: 프로젝트 명령어는 Git에 포함시켜 팀과 공유