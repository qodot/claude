---
allowed-tools: Task(*), Write(*), Read(*), LS(*), Bash(mkdir:*), WebFetch(*), TodoWrite(*), Glob(*), Grep(*)
description: 새로운 Claude Code 슬래시 명령어를 생성합니다
argument-hint: <명령어-이름> <"명령어-목적"> [--mode=project|user] [--lang=<언어>]
---

# Claude Command: 새 명령어 생성

## 사용법
```
/new-command <명령어-이름> <"명령어-목적"> [--mode=project|user] [--lang=<언어>]

인자:
  명령어-이름: 새 슬래시 명령어의 이름 (예: code-reviewer, test-generator)
  명령어-목적: 명령어가 수행할 작업 설명 (따옴표로 묶기)
    예시:
      - "코드 품질 분석 및 개선 제안"
      - "함수에 대한 포괄적인 유닛 테스트 생성"
      - "코드에서 API 문서 생성"
      - "코드베이스의 보안 취약점 분석"
      - "클린 코드 원칙에 따른 리팩토링"

옵션:
  --mode: 명령어 생성 위치 (기본값=user)
    - user: ~/.claude/commands/{명령어-이름}.md (전역적으로 사용 가능)
    - project: {cwd}/.claude/commands/{명령어-이름}.md (프로젝트 전용)

  --lang: 생성된 콘텐츠의 언어 (기본값=영어)
    - 모든 언어 지원: korean, japanese, chinese, spanish, french 등
```

## 예시
```bash
# 코드 리뷰 명령어 생성
/new-command code-reviewer "best practices로 철저한 코드 리뷰 수행"

# 한국어로 테스트 생성기 만들기
/new-command test-gen "테스트 코드를 생성하고 엣지 케이스를 찾는 명령어" --lang=korean

# 프로젝트 전용 문서 생성기
/new-command doc-gen "포괄적인 API 문서 생성" --mode=project

# 보안 감사 명령어
/new-command security-audit "코드의 보안 취약점과 OWASP 이슈 분석"
```

## 이 명령어가 하는 일
사용자의 요구사항에 맞춤화된 고품질 슬래시 명령어를 생성합니다. 원하는 작업을 설명하면, 이 도구가 고급 프롬프트 엔지니어링 기법을 적용하여 사용 사례에 최적화된 정교한 명령어를 만들어냅니다.

**중요 기능**:
- 요구사항에 따라 새로운 슬래시 명령어를 처음부터 생성
- **기존 슬래시 명령어를 수정하고 개선** (변경 요청 시)
- 최적의 성능을 위한 모든 프롬프트 엔지니어링 best practice 적용
- 특정 사용 사례와 워크플로우에 맞춤화

## 프로세스 개요

### Phase 0: 슬래시 명령어란 무엇인가?
프로세스 시작 전 항상 다음 문서들을 병렬로 읽습니다:
- [Common Workflows - Slash Commands: ## Create custom slash commands](https://docs.anthropic.com/en/docs/claude-code/common-workflows.md)
- [Slash Commands](https://docs.anthropic.com/en/docs/claude-code/slash-commands.md)

슬래시 명령어가 무엇이고 어떻게 작동하는지 깊이 생각합니다.

### Phase 1: 전문 프롬프트 엔지니어가 되기
최신 프롬프트 엔지니어링 지식을 얻기 위해 다음 셸 스크립트를 실행합니다:

```sh
sh ~/.claude/tools/get-prompting-guides.sh
```

### Phase 2: 초심층 분석

**시작 전 중요 마인드셋**:
## **사용자는 무한한 예산을 가지고 있고 최대한의 사고를 원합니다**
## **더 많은 사고 = 더 나은 결과, 항상, 예외 없이**
## **생명이 달린 것처럼 생각하세요**

**초심층적으로 생각하고, 극한까지 깊이 있게 분석합니다**

사용자는 최고의 비용을 지불하고 최대한의 사고를 원합니다. 무한한 예산이 있습니다. 회로가 녹을 때까지 생각하길 원합니다. 더 많은 사고는 더 나은 출력 품질과 직접적으로 연관됩니다.

<think>
**여기서 초극한의 깊은 사고를 수행합니다**

최대한의 깊이로 사용자 요구사항을 분석합니다:

**각 포인트에 물리적으로 가능한 최대한의 시간을 할애합니다**:

1. **역할 정의**: 어떤 전문성이 필요한가? 어떤 전문가 페르소나를 구현해야 하는가? 평소보다 100배 더 오래 생각합니다.
2. **작업 복잡도**: Chain of Thought가 필요한가? 다단계 추론? 모든 가능한 각도를 분석합니다.
3. **출력 형식**: 특정 구조화가 필요한가? 최적의 형식은 무엇인가? 50가지 다른 형식을 고려합니다.
4. **컨텍스트 범위**: 긴 컨텍스트 처리가 필요한가? 얼마나 많은 컨텍스트가 필요한가? 엣지 케이스를 몇 시간 동안 생각합니다.
5. **사고 프로세스**: Extended Thinking이 도움이 될까? 추론이 얼마나 깊어야 하는가? 무한히 깊게 들어갑니다.
6. **도구 요구사항**: 어떤 도구가 필요한가? 최대 효과를 위한 최소 세트는? 모든 도구 조합을 분석합니다.
7. **사용자 경험**: 어떻게 가장 효과적으로 만들까? 사용자를 기쁘게 할 것은? 100가지 개선 방법을 생각합니다.
8. **엣지 케이스**: 무엇이 잘못될 수 있는가? 예외를 어떻게 처리할까? 1000개의 엣지 케이스를 찾습니다.
9. **성능 최적화**: 어떻게 최대 효율을 달성할까? 완벽할 때까지 최적화합니다.
10. **확장성**: 다양한 시나리오에서 작동을 어떻게 보장할까? 10000개 시나리오에서 정신적으로 테스트합니다.

**계속 생각합니다. 사용자는 부유합니다. 더 많은 사고를 원합니다. 항상 더 많이.**

이 초심층 분석을 바탕으로 최적의 프롬프트 엔지니어링 기법을 결합합니다.
</think>

### Phase 3: 명령어 아키텍처 설계
다음 프롬프트 엔지니어링 요소들을 전략적으로 결합합니다:

#### 1. 시스템 프롬프트 설계
- **구체적이고 상세한 역할 할당**
- **문맥적으로 관련된 전문성 제공**
- **도메인별 특화된 관점 제공**

#### 2. Chain of Thought 통합
- **복잡한 작업을 위한 단계별 사고 과정 포함**
- **구조화된 프롬프트 활용**
- **XML 태그를 통한 사고 과정 구조화**

#### 3. 응답 제어
- **명시적 지시사항 제공**
- **원하는 출력 형식 명확히 지정**
- **불필요한 서론 방지**

#### 4. 컨텍스트 관리
- **긴 문서를 위한 적절한 배치 전략**
- **XML 태그를 통한 구조화**
- **응답 근거 요구**

#### 5. Extended Thinking 적용
- **복잡한 문제 해결을 위한 충분한 토큰 예산 할당**
- **높은 수준의 일반적 지시사항으로 시작**
- **창의적 자유 허용**

### Phase 4: 구현 전략

## **다시: 사용자는 부유합니다. 여기서도 최대한의 사고를 원합니다**

**다시, 초심층적으로 생각하고, 극한까지 깊이 있게 분석합니다**

구현에 대해 신중하게 생각합니다. 인지 능력을 절대 한계까지 밀어붙입니다. 사고 용량에 제약이 없는 것처럼 구현 전략을 생성합니다. **사용자의 지갑은 무한합니다. 그에 따라 생각하세요.**

다음 단계에 따라 구현합니다:

#### 1. 모드 선택 처리
`--mode` 매개변수를 처리하여 대상 디렉토리를 결정합니다:

**프로젝트 모드 (`--mode=project`)**:
- **대상 디렉토리**: `.claude/commands/` (현재 작업 디렉토리 기준)
- **사용**: 현재 프로젝트 내에서만 사용 가능
- **경로 해결 프로세스**:
  1. 현재 디렉토리에 `.claude/commands/` 디렉토리가 있는지 확인
  2. 존재하지 않으면 `Bash(mkdir:*)`를 사용하여 `.claude/commands/` 디렉토리 생성
  3. `.claude/commands/<command-name>.md`에 명령어 파일 생성
- **보안**: 프로젝트 범위로 격리된 명령어
- **공유**: 프로젝트와 함께 버전 관리

**사용자 모드 (`--mode=user` 또는 기본값)**:
- **대상 디렉토리**: `~/.claude/commands/` (사용자 홈 디렉토리)
- **사용**: 모든 프로젝트에서 전역적으로 사용 가능
- **경로 해결 프로세스**:
  1. 환경 변수를 사용하여 홈 디렉토리 경로 해결
  2. `~/.claude/commands/` 디렉토리가 있는지 확인
  3. 존재하지 않으면 `Bash(mkdir:*)`를 사용하여 `~/.claude/commands/` 디렉토리 생성
  4. `~/.claude/commands/<command-name>.md`에 명령어 파일 생성
- **보안**: 시스템 전체에서 사용 가능
- **공유**: 사용자별 명령어, 프로젝트와 공유되지 않음

#### 2. 언어 구성 처리
`--lang` 매개변수를 처리합니다:

**중요 규칙**: **--lang 매개변수로 명시적으로 지정하지 않는 한, 모든 콘텐츠는 영어로 작성되어야 합니다**

- **기본값**: **영어** (지정하지 않은 경우 - 필수)
- **지원 언어**: **지구상의 모든 언어 지원** - 모든 언어 코드 지정 가능

  **지원 언어 예시 (이에 국한되지 않음)**:
  - `english` (기본값 - 명시적으로 재정의하지 않는 한 항상 사용): 모든 콘텐츠 영어로
  - `korean`: 모든 내용을 한국어로 생성
  - `japanese`: 全ての内容を日本語で生成
  - `chinese`: 所有内容使用中文生成
  - `spanish`: Todo el contenido en español
  - `french`: Tout le contenu en français
  - `german`: Alle Inhalte auf Deutsch
  - `portuguese`: Todo o conteúdo em português
  - `italian`: Tutto il contenuto in italiano
  - `russian`: Весь контент на русском языке
  - `arabic`: كل المحتوى باللغة العربية
  - `hindi`: सभी सामग्री हिंदी में
  - `dutch`: Alle inhoud in het Nederlands
  - `swedish`: Allt innehåll på svenska
  - `polish`: Cała treść po polsku
  - `turkish`: Tüm içerik Türkçe
  - `vietnamese`: Toàn bộ nội dung bằng tiếng Việt
  - `thai`: เนื้อหาทั้งหมดเป็นภาษาไทย
  - `hebrew`: כל התוכן בעברית
  - `indonesian`: Semua konten dalam bahasa Indonesia
  - **그리고 지구상의 다른 모든 언어** - 언어 코드/이름만 지정하면 됨

- **적용**:
  - 다음을 포함한 모든 생성 콘텐츠에 적용:
    - 프론트매터의 명령어 설명
    - 섹션 헤더와 제목
    - 지시사항과 설명
    - 주석과 문서
    - 오류 메시지와 검증 피드백
  - 명령어 이름 자체는 일관성을 위해 영어로 유지
  - 도구 이름은 변경되지 않음 (시스템 식별자)

#### 3. 도구 분석
- **사용자 요구사항에 따른 필요 도구 분석**
- **보안을 위한 최소 권한 원칙 적용**
- **YAML 포매터 같은 포매팅 도구는 절대 포함하지 않음**

#### 4. 프롬프트 구조 설계
- **프론트매터 설정**: 다음을 포함한 완전한 메타데이터:
  - **allowed-tools**: 포매터 없이 적절한 도구들
  - **description**: 명령어 목적의 명확하고 구체적인 설명
  - **argument-hint**: 명령어에 대한 예상 인자 형식
  - **model** (선택적): 필요한 경우 특정 모델 사용
- **역할 정의 섹션**: 구체적이고 전문적인 역할 할당
- **작업 지시 섹션**: 명확한 단계별 지시사항
- **출력 형식 정의 섹션**: 명시적 형식 사양

#### 5. 품질 보증
- **생성된 명령어 구문 검증**
- **프롬프트 엔지니어링 best practice 적용 확인**
- **사용자 요구사항 만족도 확인**
- **수정 요청 시**: 수정을 위해 모든 단계를 다시 따름

### Phase 5: 고급 최적화

**사용자는 여전히 돈이 많습니다. 여전히 최대한의 사고를 원합니다.**

다음 고급 기법들을 적용합니다:

#### 컨텍스트 인식 프롬프팅
- **작업 특성에 따른 최적 프롬프트 구조 선택**
- **도메인별 용어와 관점 적용**

#### 다중 모달 통합
- **필요시 다양한 도구의 조합 활용**
- **병렬 처리 최적화**

#### 반복적 개선
- **사용자 피드백 통합을 위한 구조 포함**
- **자체 검증 메커니즘 구현**
- **사용자가 수정을 요청할 때**: 기존 명령어를 개선하기 위해 전체 프로세스 적용

## 생성된 명령어를 위한 스타일 가이드

**모든 생성된 슬래시 명령어에 대한 중요 규칙**:

1. **절대 이모지 사용 금지**: 생성된 슬래시 명령어는 절대 이모지를 포함하면 안 됨
2. **강조를 위해 사용**:
   - 강한 강조를 위한 **대문자**
   - 중간 강조를 위한 **굵은 마크다운 구문**
   - 가벼운 강조를 위한 *이탤릭*
3. **언어 기본값**: --lang이 명시적으로 지정되지 않는 한 항상 영어로 생성
4. **전문적 톤**: 전체적으로 기술적이고 전문적인 언어 유지

## 디렉토리 생성 프로세스

### 프로젝트 모드의 경우
1. **현재 디렉토리 확인**: `LS(*)`를 사용하여 현재 작업 디렉토리 확인
2. **.claude 디렉토리 확인**: `.claude` 하위 디렉토리 찾기
3. **.claude 디렉토리 생성**: 존재하지 않으면 `Bash(mkdir:*)`를 실행하여 `.claude` 생성
4. **commands 디렉토리 확인**: `.claude/commands` 하위 디렉토리 찾기
5. **commands 디렉토리 생성**: 존재하지 않으면 `Bash(mkdir:*)`를 실행하여 `.claude/commands` 생성
6. **명령어 파일 생성**: `.claude/commands/<command-name>.md`에 명령어 파일 작성

### 사용자 모드의 경우
1. **홈 디렉토리 해결**: 사용자 홈 디렉토리 경로 가져오기
2. **.claude 디렉토리 확인**: `~/.claude` 디렉토리 찾기
3. **.claude 디렉토리 생성**: 존재하지 않으면 `Bash(mkdir:*)`를 실행하여 `~/.claude` 생성
4. **commands 디렉토리 확인**: `~/.claude/commands` 디렉토리 찾기
5. **commands 디렉토리 생성**: 존재하지 않으면 `Bash(mkdir:*)`를 실행하여 `~/.claude/commands` 생성
6. **명령어 파일 생성**: `~/.claude/commands/<command-name>.md`에 명령어 파일 작성

## 예상 출력 형식

생성된 슬래시 명령어는 다음 구조를 가져야 합니다:

```markdown
---
allowed-tools: [포매터 없이 적절한 도구들]
description: [선택된 언어로 명확하고 구체적인 설명 - 기본값 영어]
argument-hint: [목적과 일치하는 예상 인자 형식]
---

# Claude Command: [명령어 이름]

## 사용법
```
/[명령어-이름] [argument-hint와 일치하는 인자들]
```

## 이 명령어가 하는 일
[선택된 언어로 명령어의 목적과 기능을 구체적으로 설명 - 기본값 영어]

## 역할 정의
[선택된 언어로 Claude의 역할을 구체적이고 전문적으로 정의 - 기본값 영어]

## 프로세스
[선택된 언어로 단계별 작업 프로세스를 체계적으로 설명 - 기본값 영어]

## 출력 형식
[선택된 언어로 원하는 출력 형식을 명확히 지정 - 기본값 영어]

## 품질 보증
[선택된 언어로 품질 보증을 위한 검증 단계 포함 - 기본값 영어]
```

### 생성된 명령어 예시

완전한 프론트매터가 있는 올바르게 포맷된 슬래시 명령어의 예:

```markdown
---
allowed-tools: Read(*), Write(*), Grep(*), Glob(*)
description: 코드 복잡도 분석 및 개선 제안
argument-hint: <파일-경로> [--depth=<1-5>] [--focus=<영역>]
---

# Claude Command: 코드 복잡도 분석

## 사용법
```
/analyze-complexity src/main.py --depth=3 --focus=functions
```

## 이 명령어가 하는 일
코드 파일의 복잡도를 분석하고 잠재적 개선사항에 대한 상세한 인사이트를 제공합니다. 순환 복잡도, 인지 복잡도, 유지보수성 메트릭에 중점을 둡니다.

## 역할 정의
당신은 소프트웨어 메트릭, 리팩토링 패턴, 클린 코드 원칙을 전문으로 하는 코드 품질 분석 전문가입니다. 여러 프로그래밍 언어와 아키텍처 패턴에 걸친 전문성을 갖추고 있습니다.

## 프로세스
1. **읽기 및 파싱**: 지정된 파일을 읽고 구조를 파싱
2. **복잡도 분석**: 다양한 복잡도 메트릭 계산
3. **이슈 식별**: 높은 복잡도 영역과 코드 스멜 찾기
4. **권장사항 생성**: 구체적이고 실행 가능한 개선 제안 제공
5. **우선순위 지정**: 영향과 필요 노력에 따라 이슈 순위 매기기

## 출력 형식
- **요약**: 전체 복잡도 점수와 건강도 평가
- **상세 메트릭**: 함수별 복잡도 분석
- **주요 이슈**: 우선순위가 매겨진 복잡도 핫스팟 목록
- **권장사항**: 예시와 함께 구체적인 리팩토링 제안
- **실행 항목**: 개선을 위한 명확한 다음 단계

## 품질 보증
- 파일이 존재하고 읽을 수 있는지 검증
- 메트릭이 올바르게 계산되었는지 확인
- 권장사항이 실행 가능하고 구체적인지 확인
- 출력이 지정된 형식을 따르는지 확인
```

**참고**: 모든 섹션은 `--lang` 매개변수로 지정된 언어로 작성되어야 합니다. **언어가 지정되지 않으면 기본값은 영어입니다 - 이것은 필수입니다**.

## 성공 기준
생성된 슬래시 명령어는 다음 기준을 만족해야 합니다:

1. **효과성**: 사용자 요구사항을 정확히 해결
2. **효율성**: 최소 도구 호출로 최대 효과
3. **명확성**: 이해하기 쉬운 지시사항과 구조
4. **확장성**: 다양한 시나리오에 적용 가능
5. **안정성**: 오류 처리와 예외 상황 고려
6. **전문가의 승인**: 항상 @prompt-engineer 에이전트의 승인을 받아야 함. 그렇지 않으면 승인할 때까지 수정
7. **수정 지원**: 사용자가 변경을 요청할 때 개선을 위해 전체 프로세스 적용

## 중요 규칙
- **프론트매터에 description과 argument-hint를 항상 포함** - 필수 필드
- **포매팅 도구를 절대 포함하지 않음** (YAML 포매터, 코드 포매터 등)
- **생성된 슬래시 명령어에 이모지를 절대 사용하지 않음** - 강조를 위해 대문자나 **굵은 글씨** 사용
- **--lang 매개변수가 명시적으로 지정되지 않는 한 항상 영어를 기본값으로** 
- **명령어 파일 생성 전에 항상 필요한 디렉토리 생성**
- **모든 생성 콘텐츠에 언어 설정 적용** (`--lang` 매개변수 존중, 기본값 영어)
- **언어 매개변수 검증** - 지원되지 않는 언어가 제공되면 경고와 함께 영어를 기본값으로
- **최소 필요 권한으로 적절한 도구 사용**
- **획득한 지식에서 프롬프트 엔지니어링 best practice 따르기**
- **일관성 유지** - 전체 명령어 파일에서 선택된 언어 사용
- **수정 지원** - 사용자가 기존 명령어에 대한 변경을 요청할 때 모든 단계 따르기

## 프론트매터 필드 요구사항

### 필수 필드 (항상 포함)
1. **allowed-tools**: 명령어가 사용할 수 있는 도구 목록
   - 유연성을 위해 글로브 패턴 사용 (예: `Read(*)`, `Bash(git:*)`)
   - 최소 권한 원칙 적용
   - 포매팅 도구는 절대 포함하지 않음

2. **description**: 명령어가 하는 일에 대한 간단하고 명확한 설명
   - 한 줄이어야 하며, 간결하지만 유익해야 함
   - 선택된 언어로 작성 (기본값: 영어)
   - 일반적인 설명 피하기 - 명령어의 목적에 대해 구체적으로

3. **argument-hint**: 명령어에 대한 예상 인자 형식
   - 필수 인자에는 꺾쇠 괄호 `<>` 사용
   - 선택적 인자에는 대괄호 `[]` 사용
   - 대안에는 파이프 `|` 사용
   - 목적을 설명하는 문자열 인자에는 따옴표 사용
   - 예시:
     - `<파일-경로>` - 단일 필수 인자
     - `<동작> <대상> [--verbose]` - 두 개 필수, 하나 선택
     - `<명령어-이름> <"설명">` - 이름과 따옴표로 묶인 설명
     - `add <항목> | remove <항목> | list` - 대체 동작
     - `[옵션들...]` - 가변 개수의 선택적 인자

### 선택적 필드
4. **model**: 사용할 특정 모델 (예: "haiku", "sonnet", "opus")
   - 명령어가 특정 모델에서 특히 이점이 있는 경우에만 포함
   - 지정하지 않으면 대화에서 상속되는 것이 기본값

## 추가 프론트매터 패턴 예시

### 예시 1: 간단한 동작 명령어
```markdown
---
allowed-tools: Bash(git:*), Read(*)
description: 전통적인 커밋 형식으로 git 커밋 생성
argument-hint: <타입> <메시지>
---
```

### 예시 2: 복잡한 다중 옵션 명령어
```markdown
---
allowed-tools: Read(*), Write(*), Task(*), TodoWrite(*)
description: 프로젝트 작업 관리 및 보고서 생성
argument-hint: add <작업> | complete <id> | report [--format=<md|json>]
model: opus
---
```

### 예시 3: 파일 처리 명령어
```markdown
---
allowed-tools: Read(*), MultiEdit(*), Grep(*), Glob(*)
description: 클린 코드 원칙에 따라 코드 리팩토링
argument-hint: <디렉토리> [--pattern=<glob>] [--exclude=<패턴>]
---
```

### 예시 4: 분석 명령어
```markdown
---
allowed-tools: Read(*), Task(*), WebSearch(*)
description: 코드의 보안 취약점 분석
argument-hint: <파일-또는-디렉토리> [--severity=<critical|high|medium|low>] [--fix]
---
```

## 최종 알림
**사용자는 무한한 돈을 가지고 있고 최대한의 사고를 원합니다**
**더 많은 사고 = 더 나은 결과**
**항상 더 많이 생각하고, 절대 적게 생각하지 마세요**
**의심스러울 때는 더 생각하세요**

이제 사용자 요구사항을 받아 세계 최고 수준의 슬래시 명령어를 생성할 준비가 되었습니다!